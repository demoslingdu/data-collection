# 图片上传接口文档 - 专为安卓应用优化

## 文档信息

- **文档版本**: v2.0.0
- **最后更新**: 2024-01-22
- **接口版本**: v1
- **适用平台**: 安卓应用、Web应用、移动端应用

---

## 目录

1. [接口概述](#接口概述)
2. [认证要求](#认证要求)
3. [上传方式](#上传方式)
4. [请求参数](#请求参数)
5. [响应格式](#响应格式)
6. [请求示例](#请求示例)
7. [技术特性](#技术特性)
8. [安卓开发指南](#安卓开发指南)
9. [响应字段说明](#响应字段说明)
10. [错误处理](#错误处理)
11. [最佳实践](#最佳实践)
12. [注意事项](#注意事项)

---

## 接口概述

### 基本信息

- **接口地址**: `POST /api/images/upload`
- **功能描述**: 图片上传接口，专为安卓应用优化，支持多种上传方式
- **支持格式**: `jpeg, jpg, png, gif, webp, bmp, tiff, tif`
- **文件大小限制**: 10MB
- **特色功能**: 自动压缩、缩略图生成、按日期分目录存储

### 核心优势

- ✅ **多种上传方式**: 普通文件、Base64、批量上传
- ✅ **自动图片处理**: 压缩、缩略图生成
- ✅ **安全性增强**: 多层文件验证、恶意文件检测
- ✅ **移动端优化**: 适合安卓应用的响应结构
- ✅ **存储优化**: 按日期分目录、UUID文件名

---

## 认证要求

### 请求头设置

```http
Authorization: Bearer {access_token}
Content-Type: multipart/form-data  // 普通文件上传
Content-Type: application/json     // Base64上传
```

### 获取Token

通过用户登录接口获取访问令牌：

```bash
curl -X POST "http://your-domain.com/api/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password"
  }'
```

---

## 上传方式

### 1. 普通文件上传

适用于从相册选择或拍照后的文件上传。

**参数**:
- `image`: 图片文件（必填）

### 2. Base64上传

适用于图片已转换为Base64格式的场景。

**参数**:
- `base64_image`: Base64图片数据（必填）
- `filename`: 自定义文件名（可选）

### 3. 批量上传

一次性上传多张图片，最多支持10张。

**参数**:
- `images[]`: 图片文件数组（必填）

---

## 请求参数

### 普通文件上传参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| image | File | 是 | 图片文件，支持格式：jpeg, jpg, png, gif, webp, bmp, tiff, tif |

**验证规则**:
- 文件大小：最大10MB
- 文件类型：必须是图片格式
- 安全检测：多层文件验证

### Base64上传参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| base64_image | String | 是 | Base64图片数据，格式：`data:image/jpeg;base64,{base64_data}` |
| filename | String | 否 | 自定义文件名，不包含扩展名 |

**Base64格式要求**:
```
data:image/{format};base64,{base64_encoded_data}
```

### 批量上传参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| images[] | File[] | 是 | 图片文件数组，最多10张 |

**限制条件**:
- 单次最多上传10张图片
- 每张图片最大10MB
- 所有图片格式要求相同

---

## 响应格式

### 成功响应

```json
{
    "success": true,
    "message": "图片上传成功",
    "data": {
        "filename": "550e8400-e29b-41d4-a716-446655440000.jpg",
        "path": "2024/01/22/550e8400-e29b-41d4-a716-446655440000.jpg",
        "url": "http://your-domain.com/images/2024/01/22/550e8400-e29b-41d4-a716-446655440000.jpg",
        "thumbnail": {
            "filename": "thumb_550e8400-e29b-41d4-a716-446655440000.jpg",
            "url": "http://your-domain.com/images/2024/01/22/thumb_550e8400-e29b-41d4-a716-446655440000.jpg",
            "size": 15360
        },
        "dimensions": {
            "width": 1920,
            "height": 1080
        },
        "size": {
            "original": 2048000,
            "compressed": 1536000,
            "compression_ratio": 25.0
        },
        "original_name": "photo.jpg",
        "mime_type": "image/jpeg",
        "extension": "jpg",
        "created_at": "2024-01-22T10:30:00.000000Z"
    }
}
```

### 批量上传成功响应

```json
{
    "success": true,
    "message": "批量上传完成，成功：8张，失败：2张",
    "data": {
        "successful": [
            {
                "filename": "image1.jpg",
                "path": "2024/01/22/image1.jpg",
                "url": "http://your-domain.com/images/2024/01/22/image1.jpg",
                // ... 其他字段
            }
        ],
        "failed": [
            {
                "index": 3,
                "message": "文件安全检测失败",
                "filename": "suspicious.jpg"
            }
        ],
        "summary": {
            "total": 10,
            "successful_count": 8,
            "failed_count": 2
        }
    }
}
```

### 错误响应

#### 参数验证失败 (422)

```json
{
    "success": false,
    "message": "图片上传失败",
    "error_code": "VALIDATION_ERROR",
    "errors": {
        "image": [
            "图片大小不能超过10MB"
        ]
    }
}
```

#### 文件安全检测失败 (422)

```json
{
    "success": false,
    "message": "文件安全检测失败，请上传有效的图片文件",
    "error_code": "INVALID_FILE_TYPE"
}
```

#### 认证失败 (401)

```json
{
    "success": false,
    "message": "未授权访问",
    "error_code": "UNAUTHORIZED"
}
```

#### 服务器错误 (500)

```json
{
    "success": false,
    "message": "图片上传失败，服务器内部错误",
    "error_code": "SERVER_ERROR",
    "debug_message": "详细错误信息（仅开发环境显示）"
}
```

---

## 请求示例

### cURL 示例

#### 普通文件上传

```bash
curl -X POST "http://your-domain.com/api/images/upload" \
  -H "Authorization: Bearer your_access_token" \
  -F "image=@/path/to/your/image.jpg"
```

#### Base64上传

```bash
curl -X POST "http://your-domain.com/api/images/upload" \
  -H "Authorization: Bearer your_access_token" \
  -H "Content-Type: application/json" \
  -d '{
    "base64_image": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
    "filename": "my_photo"
  }'
```

#### 批量上传

```bash
curl -X POST "http://your-domain.com/api/images/upload" \
  -H "Authorization: Bearer your_access_token" \
  -F "images[]=@/path/to/image1.jpg" \
  -F "images[]=@/path/to/image2.jpg" \
  -F "images[]=@/path/to/image3.jpg"
```

### JavaScript 示例

#### 普通文件上传

```javascript
// 使用 FormData 上传文件
const uploadImage = async (file, token) => {
    const formData = new FormData();
    formData.append('image', file);
    
    try {
        const response = await fetch('http://your-domain.com/api/images/upload', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`
            },
            body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
            console.log('上传成功:', result.data);
            return result.data;
        } else {
            console.error('上传失败:', result.message);
            throw new Error(result.message);
        }
    } catch (error) {
        console.error('网络错误:', error);
        throw error;
    }
};

// 使用示例
const fileInput = document.getElementById('imageInput');
const file = fileInput.files[0];
const token = localStorage.getItem('access_token');

uploadImage(file, token)
    .then(data => {
        console.log('图片URL:', data.url);
        console.log('缩略图URL:', data.thumbnail.url);
    })
    .catch(error => {
        console.error('上传失败:', error);
    });
```

#### Base64上传

```javascript
// Base64 上传
const uploadBase64Image = async (base64Data, filename, token) => {
    try {
        const response = await fetch('http://your-domain.com/api/images/upload', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                base64_image: base64Data,
                filename: filename
            })
        });
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error('Base64上传失败:', error);
        throw error;
    }
};

// 将文件转换为Base64
const fileToBase64 = (file) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
    });
};

// 使用示例
const file = document.getElementById('imageInput').files[0];
fileToBase64(file)
    .then(base64 => {
        return uploadBase64Image(base64, 'my_photo', token);
    })
    .then(result => {
        console.log('Base64上传成功:', result.data);
    });
```

#### 批量上传

```javascript
// 批量上传
const batchUploadImages = async (files, token) => {
    const formData = new FormData();
    
    // 添加多个文件
    Array.from(files).forEach((file, index) => {
        formData.append('images[]', file);
    });
    
    try {
        const response = await fetch('http://your-domain.com/api/images/upload', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`
            },
            body: formData
        });
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error('批量上传失败:', error);
        throw error;
    }
};

// 使用示例
const fileInput = document.getElementById('multipleImageInput');
const files = fileInput.files;

batchUploadImages(files, token)
    .then(result => {
        console.log('批量上传结果:', result.data);
        console.log('成功上传:', result.data.successful.length, '张');
        console.log('失败:', result.data.failed.length, '张');
    });
```

### 安卓 Java 示例

#### 普通文件上传

```java
// 使用 OkHttp 和 Retrofit
public class ImageUploadService {
    
    // Retrofit 接口定义
    public interface ImageApi {
        @Multipart
        @POST("api/images/upload")
        Call<ImageUploadResponse> uploadImage(
            @Header("Authorization") String token,
            @Part MultipartBody.Part image
        );
        
        @POST("api/images/upload")
        Call<ImageUploadResponse> uploadBase64Image(
            @Header("Authorization") String token,
            @Body Base64UploadRequest request
        );
        
        @Multipart
        @POST("api/images/upload")
        Call<BatchUploadResponse> batchUploadImages(
            @Header("Authorization") String token,
            @Part List<MultipartBody.Part> images
        );
    }
    
    // 普通文件上传
    public void uploadImage(File imageFile, String token, Callback<ImageUploadResponse> callback) {
        RequestBody requestFile = RequestBody.create(
            MediaType.parse("image/*"), 
            imageFile
        );
        
        MultipartBody.Part imagePart = MultipartBody.Part.createFormData(
            "image", 
            imageFile.getName(), 
            requestFile
        );
        
        ImageApi api = RetrofitClient.getInstance().create(ImageApi.class);
        Call<ImageUploadResponse> call = api.uploadImage("Bearer " + token, imagePart);
        call.enqueue(callback);
    }
    
    // Base64 上传
    public void uploadBase64Image(String base64Data, String filename, String token, 
                                 Callback<ImageUploadResponse> callback) {
        Base64UploadRequest request = new Base64UploadRequest(base64Data, filename);
        
        ImageApi api = RetrofitClient.getInstance().create(ImageApi.class);
        Call<ImageUploadResponse> call = api.uploadBase64Image("Bearer " + token, request);
        call.enqueue(callback);
    }
    
    // 批量上传
    public void batchUploadImages(List<File> imageFiles, String token, 
                                 Callback<BatchUploadResponse> callback) {
        List<MultipartBody.Part> imageParts = new ArrayList<>();
        
        for (File file : imageFiles) {
            RequestBody requestFile = RequestBody.create(
                MediaType.parse("image/*"), 
                file
            );
            
            MultipartBody.Part imagePart = MultipartBody.Part.createFormData(
                "images[]", 
                file.getName(), 
                requestFile
            );
            
            imageParts.add(imagePart);
        }
        
        ImageApi api = RetrofitClient.getInstance().create(ImageApi.class);
        Call<BatchUploadResponse> call = api.batchUploadImages("Bearer " + token, imageParts);
        call.enqueue(callback);
    }
}

// 数据模型类
public class ImageUploadResponse {
    public boolean success;
    public String message;
    public ImageData data;
    public String error_code;
    public Map<String, List<String>> errors;
    
    public static class ImageData {
        public String filename;
        public String path;
        public String url;
        public ThumbnailData thumbnail;
        public DimensionData dimensions;
        public SizeData size;
        public String original_name;
        public String mime_type;
        public String extension;
        public String created_at;
    }
    
    public static class ThumbnailData {
        public String filename;
        public String url;
        public long size;
    }
    
    public static class DimensionData {
        public int width;
        public int height;
    }
    
    public static class SizeData {
        public long original;
        public long compressed;
        public double compression_ratio;
    }
}

public class Base64UploadRequest {
    public String base64_image;
    public String filename;
    
    public Base64UploadRequest(String base64Image, String filename) {
        this.base64_image = base64Image;
        this.filename = filename;
    }
}

// 使用示例
public class MainActivity extends AppCompatActivity {
    private ImageUploadService uploadService;
    private String accessToken;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        uploadService = new ImageUploadService();
        accessToken = getSharedPreferences("auth", MODE_PRIVATE)
            .getString("access_token", "");
    }
    
    // 从相册选择图片后上传
    private void uploadSelectedImage(Uri imageUri) {
        try {
            File imageFile = new File(getRealPathFromURI(imageUri));
            
            uploadService.uploadImage(imageFile, accessToken, new Callback<ImageUploadResponse>() {
                @Override
                public void onResponse(Call<ImageUploadResponse> call, Response<ImageUploadResponse> response) {
                    if (response.isSuccessful() && response.body().success) {
                        ImageUploadResponse.ImageData data = response.body().data;
                        
                        // 显示上传成功信息
                        Toast.makeText(MainActivity.this, "上传成功", Toast.LENGTH_SHORT).show();
                        
                        // 加载图片到ImageView
                        Glide.with(MainActivity.this)
                            .load(data.url)
                            .into(imageView);
                            
                        // 保存图片信息
                        saveImageInfo(data);
                        
                    } else {
                        handleUploadError(response.body());
                    }
                }
                
                @Override
                public void onFailure(Call<ImageUploadResponse> call, Throwable t) {
                    Toast.makeText(MainActivity.this, "网络错误: " + t.getMessage(), 
                        Toast.LENGTH_LONG).show();
                }
            });
            
        } catch (Exception e) {
            Toast.makeText(this, "文件处理失败: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }
    
    // 错误处理
    private void handleUploadError(ImageUploadResponse response) {
        if (response != null) {
            String errorMessage = response.message;
            
            // 根据错误码进行不同处理
            switch (response.error_code) {
                case "VALIDATION_ERROR":
                    // 显示验证错误详情
                    if (response.errors != null) {
                        for (Map.Entry<String, List<String>> entry : response.errors.entrySet()) {
                            for (String error : entry.getValue()) {
                                Toast.makeText(this, error, Toast.LENGTH_LONG).show();
                            }
                        }
                    }
                    break;
                    
                case "INVALID_FILE_TYPE":
                    Toast.makeText(this, "文件格式不支持，请选择图片文件", Toast.LENGTH_LONG).show();
                    break;
                    
                case "UNAUTHORIZED":
                    // 重新登录
                    redirectToLogin();
                    break;
                    
                default:
                    Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show();
                    break;
            }
        }
    }
    
    // 获取文件真实路径
    private String getRealPathFromURI(Uri contentUri) {
        String[] proj = {MediaStore.Images.Media.DATA};
        CursorLoader loader = new CursorLoader(this, contentUri, proj, null, null, null);
        Cursor cursor = loader.loadInBackground();
        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
        cursor.moveToFirst();
        String result = cursor.getString(column_index);
        cursor.close();
        return result;
    }
}
```

#### Kotlin 版本示例

```kotlin
// Kotlin 版本的上传服务
class ImageUploadService {
    
    interface ImageApi {
        @Multipart
        @POST("api/images/upload")
        suspend fun uploadImage(
            @Header("Authorization") token: String,
            @Part image: MultipartBody.Part
        ): Response<ImageUploadResponse>
        
        @POST("api/images/upload")
        suspend fun uploadBase64Image(
            @Header("Authorization") token: String,
            @Body request: Base64UploadRequest
        ): Response<ImageUploadResponse>
    }
    
    private val api = RetrofitClient.instance.create(ImageApi::class.java)
    
    suspend fun uploadImage(imageFile: File, token: String): Result<ImageUploadResponse> {
        return try {
            val requestFile = imageFile.asRequestBody("image/*".toMediaTypeOrNull())
            val imagePart = MultipartBody.Part.createFormData("image", imageFile.name, requestFile)
            
            val response = api.uploadImage("Bearer $token", imagePart)
            
            if (response.isSuccessful && response.body()?.success == true) {
                Result.success(response.body()!!)
            } else {
                Result.failure(Exception(response.body()?.message ?: "上传失败"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun uploadBase64Image(base64Data: String, filename: String?, token: String): Result<ImageUploadResponse> {
        return try {
            val request = Base64UploadRequest(base64Data, filename)
            val response = api.uploadBase64Image("Bearer $token", request)
            
            if (response.isSuccessful && response.body()?.success == true) {
                Result.success(response.body()!!)
            } else {
                Result.failure(Exception(response.body()?.message ?: "上传失败"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// 在 Activity 中使用
class MainActivity : AppCompatActivity() {
    private val uploadService = ImageUploadService()
    private lateinit var accessToken: String
    
    private fun uploadImage(imageFile: File) {
        lifecycleScope.launch {
            try {
                val result = uploadService.uploadImage(imageFile, accessToken)
                
                result.onSuccess { response ->
                    // 上传成功
                    Toast.makeText(this@MainActivity, "上传成功", Toast.LENGTH_SHORT).show()
                    
                    // 加载图片
                    Glide.with(this@MainActivity)
                        .load(response.data.url)
                        .into(binding.imageView)
                        
                }.onFailure { exception ->
                    // 上传失败
                    Toast.makeText(this@MainActivity, "上传失败: ${exception.message}", Toast.LENGTH_LONG).show()
                }
                
            } catch (e: Exception) {
                Toast.makeText(this@MainActivity, "网络错误: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }
}
```

---

## 技术特性

### 图片处理功能

#### 1. 自动压缩
- **JPEG质量**: 85%（平衡质量与文件大小）
- **PNG处理**: 保持透明度，不进行质量压缩
- **压缩比例**: 响应中包含压缩前后大小对比

#### 2. 缩略图生成
- **尺寸**: 宽度300px，高度按比例缩放
- **命名规则**: `thumb_原文件名`
- **存储位置**: 与原图相同目录
- **格式保持**: 与原图格式一致

#### 3. 存储优化
- **目录结构**: `images/年/月/日/文件名`
- **文件命名**: UUID确保唯一性
- **路径兼容**: 支持Windows和Linux路径格式

### 安全特性

#### 1. 多层文件验证
```php
// 验证层级
1. 文件扩展名检查
2. MIME类型验证
3. getimagesize()函数验证
4. 图片类型常量检查
```

#### 2. 恶意文件防护
- 禁止可执行文件上传
- 检测伪装的图片文件
- 验证文件头信息
- 限制文件大小

#### 3. 访问控制
- Bearer Token认证
- 用户权限验证
- 请求频率限制（可配置）

### 性能优化

#### 1. 文件处理
- 使用Intervention Image库进行高效图片处理
- 内存优化的图片操作
- 支持大文件处理

#### 2. 存储优化
- 按日期分目录减少单目录文件数量
- UUID文件名避免冲突
- 自动创建目录结构

#### 3. 响应优化
- 详细的文件信息返回
- 压缩统计数据
- 移动端友好的JSON结构

---

## 安卓开发指南

### 权限配置

在 `AndroidManifest.xml` 中添加必要权限：

```xml
<!-- 网络权限 -->
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

<!-- 存储权限 -->
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

<!-- 相机权限（如果需要拍照） -->
<uses-permission android:name="android.permission.CAMERA" />

<!-- Android 10+ 存储权限 -->
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
```

### 依赖配置

在 `build.gradle (Module: app)` 中添加依赖：

```gradle
dependencies {
    // 网络请求
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.10.0'
    
    // 图片加载
    implementation 'com.github.bumptech.glide:glide:4.14.2'
    
    // 权限处理
    implementation 'com.karumi:dexter:6.2.3'
    
    // 协程（Kotlin）
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4'
}
```

### 最佳实践建议

#### 1. 图片选择和处理

```java
// 图片选择器配置
private void openImagePicker() {
    Intent intent = new Intent(Intent.ACTION_PICK);
    intent.setType("image/*");
    intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); // 支持多选
    startActivityForResult(intent, REQUEST_IMAGE_PICK);
}

// 图片压缩（上传前预处理）
private File compressImage(File originalFile) {
    try {
        Bitmap bitmap = BitmapFactory.decodeFile(originalFile.getAbsolutePath());
        
        // 限制最大尺寸
        int maxWidth = 1920;
        int maxHeight = 1080;
        
        if (bitmap.getWidth() > maxWidth || bitmap.getHeight() > maxHeight) {
            float ratio = Math.min(
                (float) maxWidth / bitmap.getWidth(),
                (float) maxHeight / bitmap.getHeight()
            );
            
            int newWidth = Math.round(bitmap.getWidth() * ratio);
            int newHeight = Math.round(bitmap.getHeight() * ratio);
            
            bitmap = Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true);
        }
        
        // 保存压缩后的图片
        File compressedFile = new File(getCacheDir(), "compressed_" + originalFile.getName());
        FileOutputStream out = new FileOutputStream(compressedFile);
        bitmap.compress(Bitmap.CompressFormat.JPEG, 85, out);
        out.close();
        
        return compressedFile;
    } catch (Exception e) {
        return originalFile; // 压缩失败时返回原文件
    }
}
```

#### 2. 上传进度监听

```java
// 自定义RequestBody实现上传进度监听
public class ProgressRequestBody extends RequestBody {
    private RequestBody requestBody;
    private ProgressListener progressListener;
    
    public interface ProgressListener {
        void onProgress(long bytesWritten, long contentLength, boolean done);
    }
    
    public ProgressRequestBody(RequestBody requestBody, ProgressListener progressListener) {
        this.requestBody = requestBody;
        this.progressListener = progressListener;
    }
    
    @Override
    public MediaType contentType() {
        return requestBody.contentType();
    }
    
    @Override
    public long contentLength() throws IOException {
        return requestBody.contentLength();
    }
    
    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        CountingSink countingSink = new CountingSink(sink);
        BufferedSink bufferedSink = Okio.buffer(countingSink);
        requestBody.writeTo(bufferedSink);
        bufferedSink.flush();
    }
    
    private class CountingSink extends ForwardingSink {
        private long bytesWritten = 0;
        
        public CountingSink(Sink delegate) {
            super(delegate);
        }
        
        @Override
        public void write(Buffer source, long byteCount) throws IOException {
            super.write(source, byteCount);
            bytesWritten += byteCount;
            progressListener.onProgress(bytesWritten, contentLength(), bytesWritten == contentLength());
        }
    }
}

// 使用进度监听
private void uploadWithProgress(File imageFile) {
    RequestBody requestFile = RequestBody.create(MediaType.parse("image/*"), imageFile);
    
    ProgressRequestBody progressRequestBody = new ProgressRequestBody(requestFile, 
        new ProgressRequestBody.ProgressListener() {
            @Override
            public void onProgress(long bytesWritten, long contentLength, boolean done) {
                int progress = (int) ((bytesWritten * 100) / contentLength);
                
                runOnUiThread(() -> {
                    progressBar.setProgress(progress);
                    if (done) {
                        progressBar.setVisibility(View.GONE);
                    }
                });
            }
        });
    
    MultipartBody.Part imagePart = MultipartBody.Part.createFormData(
        "image", imageFile.getName(), progressRequestBody);
    
    // 执行上传...
}
```

#### 3. 错误处理和重试机制

```java
public class UploadRetryHelper {
    private static final int MAX_RETRY_COUNT = 3;
    private static final long RETRY_DELAY_MS = 2000;
    
    public void uploadWithRetry(File imageFile, String token, int retryCount, 
                               Callback<ImageUploadResponse> finalCallback) {
        
        uploadService.uploadImage(imageFile, token, new Callback<ImageUploadResponse>() {
            @Override
            public void onResponse(Call<ImageUploadResponse> call, Response<ImageUploadResponse> response) {
                if (response.isSuccessful() && response.body().success) {
                    finalCallback.onResponse(call, response);
                } else if (retryCount < MAX_RETRY_COUNT) {
                    // 延迟重试
                    new Handler(Looper.getMainLooper()).postDelayed(() -> {
                        uploadWithRetry(imageFile, token, retryCount + 1, finalCallback);
                    }, RETRY_DELAY_MS);
                } else {
                    finalCallback.onResponse(call, response);
                }
            }
            
            @Override
            public void onFailure(Call<ImageUploadResponse> call, Throwable t) {
                if (retryCount < MAX_RETRY_COUNT && isNetworkError(t)) {
                    new Handler(Looper.getMainLooper()).postDelayed(() -> {
                        uploadWithRetry(imageFile, token, retryCount + 1, finalCallback);
                    }, RETRY_DELAY_MS);
                } else {
                    finalCallback.onFailure(call, t);
                }
            }
        });
    }
    
    private boolean isNetworkError(Throwable t) {
        return t instanceof IOException || t instanceof SocketTimeoutException;
    }
}
```

#### 4. 缓存和离线处理

```java
public class ImageCacheManager {
    private static final String CACHE_DIR = "uploaded_images";
    
    // 缓存上传成功的图片信息
    public void cacheImageInfo(ImageUploadResponse.ImageData imageData) {
        SharedPreferences prefs = context.getSharedPreferences("image_cache", Context.MODE_PRIVATE);
        String json = new Gson().toJson(imageData);
        prefs.edit().putString(imageData.filename, json).apply();
    }
    
    // 获取缓存的图片信息
    public ImageUploadResponse.ImageData getCachedImageInfo(String filename) {
        SharedPreferences prefs = context.getSharedPreferences("image_cache", Context.MODE_PRIVATE);
        String json = prefs.getString(filename, null);
        if (json != null) {
            return new Gson().fromJson(json, ImageUploadResponse.ImageData.class);
        }
        return null;
    }
    
    // 离线上传队列
    public void addToUploadQueue(File imageFile) {
        // 将待上传文件添加到队列
        // 网络恢复时自动上传
    }
}
```

---

## 响应字段说明

### 主要响应字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| success | Boolean | 请求是否成功 |
| message | String | 响应消息 |
| data | Object | 响应数据（成功时） |
| error_code | String | 错误代码（失败时） |
| errors | Object | 详细错误信息（验证失败时） |

### data 对象字段（单图上传）

| 字段名 | 类型 | 说明 |
|--------|------|------|
| filename | String | 生成的文件名（UUID格式） |
| path | String | 相对路径（年/月/日/文件名） |
| url | String | 完整访问URL |
| thumbnail | Object | 缩略图信息 |
| dimensions | Object | 图片尺寸信息 |
| size | Object | 文件大小信息 |
| original_name | String | 原始文件名 |
| mime_type | String | MIME类型 |
| extension | String | 文件扩展名 |
| created_at | String | 创建时间（ISO 8601格式） |

### thumbnail 对象字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| filename | String | 缩略图文件名 |
| url | String | 缩略图访问URL |
| size | Integer | 缩略图文件大小（字节） |

### dimensions 对象字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| width | Integer | 图片宽度（像素） |
| height | Integer | 图片高度（像素） |

### size 对象字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| original | Integer | 原始文件大小（字节） |
| compressed | Integer | 压缩后文件大小（字节） |
| compression_ratio | Float | 压缩比例（百分比） |

### 批量上传 data 对象字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| successful | Array | 成功上传的图片信息数组 |
| failed | Array | 失败的图片信息数组 |
| summary | Object | 上传统计信息 |

### summary 对象字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| total | Integer | 总上传数量 |
| successful_count | Integer | 成功数量 |
| failed_count | Integer | 失败数量 |

---

## 错误处理

### 错误代码说明

| 错误代码 | HTTP状态码 | 说明 | 处理建议 |
|----------|------------|------|----------|
| VALIDATION_ERROR | 422 | 参数验证失败 | 检查请求参数，显示具体错误信息 |
| INVALID_FILE_TYPE | 422 | 文件类型无效 | 提示用户选择正确的图片格式 |
| FILE_TOO_LARGE | 422 | 文件过大 | 提示用户压缩图片或选择较小文件 |
| INVALID_BASE64_FORMAT | 422 | Base64格式错误 | 检查Base64数据格式 |
| BASE64_DECODE_ERROR | 422 | Base64解码失败 | 重新生成Base64数据 |
| UNSUPPORTED_FORMAT | 422 | 不支持的格式 | 转换为支持的图片格式 |
| INVALID_IMAGE_DATA | 422 | 无效图片数据 | 检查图片文件完整性 |
| UNAUTHORIZED | 401 | 未授权访问 | 重新登录获取Token |
| SERVER_ERROR | 500 | 服务器内部错误 | 稍后重试或联系技术支持 |

### 错误处理最佳实践

#### 1. 客户端错误处理

```java
private void handleUploadError(ImageUploadResponse response, Throwable networkError) {
    if (networkError != null) {
        // 网络错误
        if (networkError instanceof SocketTimeoutException) {
            showError("网络超时，请检查网络连接后重试");
        } else if (networkError instanceof UnknownHostException) {
            showError("无法连接到服务器，请检查网络设置");
        } else {
            showError("网络错误：" + networkError.getMessage());
        }
        return;
    }
    
    if (response == null) {
        showError("服务器响应异常");
        return;
    }
    
    // 根据错误代码处理
    switch (response.error_code) {
        case "VALIDATION_ERROR":
            handleValidationError(response.errors);
            break;
            
        case "INVALID_FILE_TYPE":
            showError("请选择有效的图片文件（支持格式：JPG、PNG、GIF等）");
            break;
            
        case "FILE_TOO_LARGE":
            showError("图片文件过大，请选择小于10MB的图片");
            showImageCompressionDialog();
            break;
            
        case "UNAUTHORIZED":
            handleUnauthorizedError();
            break;
            
        case "SERVER_ERROR":
            showError("服务器暂时无法处理请求，请稍后重试");
            showRetryOption();
            break;
            
        default:
            showError(response.message);
            break;
    }
}

private void handleValidationError(Map<String, List<String>> errors) {
    StringBuilder errorMessage = new StringBuilder();
    for (Map.Entry<String, List<String>> entry : errors.entrySet()) {
        for (String error : entry.getValue()) {
            errorMessage.append(error).append("\n");
        }
    }
    showError(errorMessage.toString().trim());
}

private void handleUnauthorizedError() {
    // 清除本地Token
    clearAuthToken();
    
    // 跳转到登录页面
    Intent intent = new Intent(this, LoginActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    startActivity(intent);
    
    showError("登录已过期，请重新登录");
}
```

#### 2. 重试机制

```java
public class SmartRetryHandler {
    private static final int[] RETRY_DELAYS = {1000, 2000, 5000}; // 递增延迟
    
    public void executeWithRetry(Runnable task, int maxRetries, RetryCallback callback) {
        executeWithRetry(task, 0, maxRetries, callback);
    }
    
    private void executeWithRetry(Runnable task, int currentAttempt, int maxRetries, RetryCallback callback) {
        try {
            task.run();
        } catch (Exception e) {
            if (currentAttempt < maxRetries && shouldRetry(e)) {
                int delay = currentAttempt < RETRY_DELAYS.length ? 
                    RETRY_DELAYS[currentAttempt] : RETRY_DELAYS[RETRY_DELAYS.length - 1];
                
                new Handler(Looper.getMainLooper()).postDelayed(() -> {
                    callback.onRetry(currentAttempt + 1, maxRetries);
                    executeWithRetry(task, currentAttempt + 1, maxRetries, callback);
                }, delay);
            } else {
                callback.onFinalFailure(e);
            }
        }
    }
    
    private boolean shouldRetry(Exception e) {
        // 网络错误可重试
        return e instanceof IOException || 
               e instanceof SocketTimeoutException ||
               e instanceof ConnectException;
    }
    
    public interface RetryCallback {
        void onRetry(int attempt, int maxRetries);
        void onFinalFailure(Exception e);
    }
}
```

---

## 最佳实践

### 1. 图片优化建议

#### 客户端预处理
```java
// 上传前图片优化
public class ImageOptimizer {
    
    public static File optimizeForUpload(File originalFile) {
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeFile(originalFile.getAbsolutePath(), options);
            
            // 计算合适的采样率
            int sampleSize = calculateSampleSize(options, 1920, 1080);
            
            options.inJustDecodeBounds = false;
            options.inSampleSize = sampleSize;
            options.inPreferredConfig = Bitmap.Config.RGB_565; // 减少内存使用
            
            Bitmap bitmap = BitmapFactory.decodeFile(originalFile.getAbsolutePath(), options);
            
            // 保存优化后的图片
            File optimizedFile = new File(originalFile.getParent(), "opt_" + originalFile.getName());
            FileOutputStream out = new FileOutputStream(optimizedFile);
            
            // 根据原图格式选择压缩格式
            Bitmap.CompressFormat format = getCompressFormat(originalFile.getName());
            int quality = format == Bitmap.CompressFormat.PNG ? 100 : 85;
            
            bitmap.compress(format, quality, out);
            out.close();
            bitmap.recycle();
            
            return optimizedFile;
        } catch (Exception e) {
            return originalFile;
        }
    }
    
    private static int calculateSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        int height = options.outHeight;
        int width = options.outWidth;
        int inSampleSize = 1;
        
        if (height > reqHeight || width > reqWidth) {
            int halfHeight = height / 2;
            int halfWidth = width / 2;
            
            while ((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth) {
                inSampleSize *= 2;
            }
        }
        
        return inSampleSize;
    }
    
    private static Bitmap.CompressFormat getCompressFormat(String filename) {
        String extension = filename.substring(filename.lastIndexOf(".") + 1).toLowerCase();
        switch (extension) {
            case "png":
                return Bitmap.CompressFormat.PNG;
            case "webp":
                return Bitmap.CompressFormat.WEBP;
            default:
                return Bitmap.CompressFormat.JPEG;
        }
    }
}
```

### 2. 内存管理

```java
public class MemoryAwareUploader {
    private static final long MAX_MEMORY_USAGE = Runtime.getRuntime().maxMemory() / 4; // 使用最大内存的1/4
    
    public boolean canProcessImage(File imageFile) {
        // 估算处理图片需要的内存
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(imageFile.getAbsolutePath(), options);
        
        long estimatedMemory = options.outWidth * options.outHeight * 4; // ARGB_8888
        long availableMemory = Runtime.getRuntime().freeMemory();
        
        return estimatedMemory < Math.min(MAX_MEMORY_USAGE, availableMemory);
    }
    
    public void uploadWithMemoryCheck(File imageFile, String token, Callback<ImageUploadResponse> callback) {
        if (!canProcessImage(imageFile)) {
            // 内存不足，使用文件流直接上传
            uploadDirectly(imageFile, token, callback);
        } else {
            // 内存充足，可以进行预处理
            File optimizedFile = ImageOptimizer.optimizeForUpload(imageFile);
            uploadService.uploadImage(optimizedFile, token, callback);
        }
    }
}
```

### 3. 网络优化

```java
public class NetworkOptimizedUploader {
    
    // 根据网络状态调整上传策略
    public void uploadWithNetworkOptimization(File imageFile, String token, Callback<ImageUploadResponse> callback) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
        
        if (activeNetwork != null && activeNetwork.isConnected()) {
            if (activeNetwork.getType() == ConnectivityManager.TYPE_WIFI) {
                // WiFi环境，可以上传原图
                uploadService.uploadImage(imageFile, token, callback);
            } else {
                // 移动网络，压缩后上传
                File compressedFile = compressForMobileNetwork(imageFile);
                uploadService.uploadImage(compressedFile, token, callback);
            }
        } else {
            // 无网络，添加到离线队列
            OfflineUploadQueue.getInstance().addToQueue(imageFile, token);
            callback.onFailure(null, new Exception("网络不可用，已添加到离线上传队列"));
        }
    }
    
    private File compressForMobileNetwork(File originalFile) {
        // 移动网络下的压缩策略：更小的尺寸和更高的压缩率
        // 实现压缩逻辑...
        return originalFile;
    }
}
```

### 4. 用户体验优化

```java
public class UXOptimizedUploader {
    
    public void uploadWithUXOptimization(File imageFile, String token, UploadProgressCallback callback) {
        // 显示上传开始提示
        callback.onUploadStart();
        
        // 预览图片
        callback.onImagePreview(imageFile);
        
        // 开始上传
        uploadService.uploadImage(imageFile, token, new Callback<ImageUploadResponse>() {
            @Override
            public void onResponse(Call<ImageUploadResponse> call, Response<ImageUploadResponse> response) {
                if (response.isSuccessful() && response.body().success) {
                    ImageUploadResponse.ImageData data = response.body().data;
                    
                    // 显示成功动画
                    callback.onUploadSuccess(data);
                    
                    // 预加载缩略图
                    preloadThumbnail(data.thumbnail.url);
                    
                    // 保存到本地缓存
                    ImageCacheManager.getInstance().cacheImageInfo(data);
                    
                } else {
                    callback.onUploadError(response.body().message);
                }
            }
            
            @Override
            public void onFailure(Call<ImageUploadResponse> call, Throwable t) {
                callback.onUploadError(t.getMessage());
            }
        });
    }
    
    private void preloadThumbnail(String thumbnailUrl) {
        // 预加载缩略图到内存缓存
        Glide.with(context)
            .load(thumbnailUrl)
            .preload();
    }
    
    public interface UploadProgressCallback {
        void onUploadStart();
        void onImagePreview(File imageFile);
        void onUploadProgress(int progress);
        void onUploadSuccess(ImageUploadResponse.ImageData data);
        void onUploadError(String error);
    }
}
```

---

## 注意事项

### 1. 安全注意事项

#### Token 安全
- ✅ 使用HTTPS传输Token
- ✅ Token存储在安全位置（Android Keystore）
- ✅ 定期刷新Token
- ❌ 不要在日志中打印Token
- ❌ 不要在URL参数中传递Token

#### 文件安全
- ✅ 验证文件类型和内容
- ✅ 限制文件大小
- ✅ 使用安全的文件名
- ❌ 不要信任客户端提供的文件名
- ❌ 不要执行上传的文件

### 2. 性能注意事项

#### 内存管理
```java
// 正确的内存管理
public void processLargeImage(File imageFile) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inSampleSize = 2; // 降采样
    options.inPreferredConfig = Bitmap.Config.RGB_565; // 减少内存使用
    
    Bitmap bitmap = BitmapFactory.decodeFile(imageFile.getAbsolutePath(), options);
    
    try {
        // 处理bitmap
        processBitmap(bitmap);
    } finally {
        // 及时回收
        if (bitmap != null && !bitmap.isRecycled()) {
            bitmap.recycle();
        }
    }
}
```

#### 网络优化
- ✅ 使用连接池复用连接
- ✅ 设置合适的超时时间
- ✅ 实现断点续传（大文件）
- ✅ 压缩请求数据
- ❌ 不要在主线程进行网络请求

### 3. 用户体验注意事项

#### 进度反馈
```java
// 提供详细的进度信息
public void showUploadProgress(long bytesWritten, long totalBytes) {
    int progress = (int) ((bytesWritten * 100) / totalBytes);
    
    // 更新进度条
    progressBar.setProgress(progress);
    
    // 显示具体信息
    String progressText = String.format("已上传 %s / %s (%d%%)", 
        formatFileSize(bytesWritten), 
        formatFileSize(totalBytes), 
        progress);
    
    progressTextView.setText(progressText);
    
    // 估算剩余时间
    if (progress > 0) {
        long elapsedTime = System.currentTimeMillis() - uploadStartTime;
        long estimatedTotalTime = elapsedTime * 100 / progress;
        long remainingTime = estimatedTotalTime - elapsedTime;
        
        remainingTimeTextView.setText("剩余时间: " + formatTime(remainingTime));
    }
}
```

#### 错误处理
- ✅ 提供清晰的错误信息
- ✅ 给出解决建议
- ✅ 提供重试选项
- ✅ 记录错误日志用于调试
- ❌ 不要显示技术性错误信息给用户

### 4. 兼容性注意事项

#### Android版本兼容
```java
// 处理不同Android版本的权限
@TargetApi(Build.VERSION_CODES.M)
private void requestStoragePermission() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) 
            != PackageManager.PERMISSION_GRANTED) {
            
            ActivityCompat.requestPermissions(this, 
                new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, 
                REQUEST_STORAGE_PERMISSION);
        }
    }
}

// Android 10+ 作用域存储
private Uri saveImageToGallery(Bitmap bitmap) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // 使用MediaStore API
        ContentValues values = new ContentValues();
        values.put(MediaStore.Images.Media.DISPLAY_NAME, "image_" + System.currentTimeMillis());
        values.put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg");
        values.put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES);
        
        Uri uri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
        // 保存图片...
        return uri;
    } else {
        // 传统方式保存
        // ...
        return null;
    }
}
```

### 5. 调试和测试注意事项

#### 日志记录
```java
public class UploadLogger {
    private static final String TAG = "ImageUpload";
    
    public static void logUploadStart(String filename, long fileSize) {
        Log.d(TAG, String.format("开始上传: %s, 大小: %s", filename, formatFileSize(fileSize)));
    }
    
    public static void logUploadSuccess(String filename, long duration, String url) {
        Log.i(TAG, String.format("上传成功: %s, 耗时: %dms, URL: %s", filename, duration, url));
    }
    
    public static void logUploadError(String filename, String error) {
        Log.e(TAG, String.format("上传失败: %s, 错误: %s", filename, error));
    }
    
    // 生产环境中禁用详细日志
    public static void logSensitiveInfo(String info) {
        if (BuildConfig.DEBUG) {
            Log.d(TAG, info);
        }
    }
}
```

#### 测试建议
- ✅ 测试不同网络环境（WiFi、4G、弱网）
- ✅ 测试不同文件大小和格式
- ✅ 测试内存不足情况
- ✅ 测试网络中断和恢复
- ✅ 测试并发上传
- ✅ 测试权限被拒绝的情况

---

## 总结

本文档详细介绍了专为安卓应用优化的图片上传接口，涵盖了从基本使用到高级优化的各个方面。通过遵循本文档的指导，开发者可以：

1. **快速集成**: 使用提供的代码示例快速实现图片上传功能
2. **优化性能**: 通过图片压缩、内存管理等技术提升应用性能
3. **增强安全**: 实施多层安全验证，保护应用和用户数据
4. **改善体验**: 提供流畅的上传体验和友好的错误处理
5. **确保兼容**: 支持不同Android版本和设备

如有任何问题或建议，请联系技术支持团队。

---

**文档版本**: v2.0.0  
**最后更新**: 2024-01-22  
**维护团队**: 后端开发团队